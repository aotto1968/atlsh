# This file tests the tclUnixFCmd.c file.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1996 Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

testConstraint testchmod [llength [info commands testchmod]]

# These tests really need to be run from a writable directory, which
# it is assumed [temporaryDirectory] is.
set oldcwd [pwd]
cd [temporaryDirectory]

# Several tests require need to match results against the unix username
set user {}
if {[testConstraint unix]} {
    catch {set user [exec whoami]}
    if {$user == ""} {
	catch {regexp {^[^(]*\(([^)]*)\)} [exec id] dummy user}
    }
    if {$user == ""} {
	set user "root"
    }
}

# Find a group that exists on this system, or else skip tests that require
# groups
testConstraint foundGroup 0
if {[testConstraint unix]} {
    catch {
	set groupList [exec groups]
	set group [lindex $groupList 0]
	testConstraint foundGroup 1
    }
}

# check whether -readonly attribute is supported
testConstraint readonlyAttr 0
if {[testConstraint unix]} {
    set f [makeFile "whatever" probe]
    catch {
	file attributes $f -readonly
	testConstraint readonlyAttr 1
    }
    removeFile probe
}

proc openup {path} {
    testchmod 777 $path
    if {[file isdirectory $path]} {
	catch {
	    foreach p [glob -directory $path *] {
		openup $p
	    }
	}
    }
}

proc cleanup {args} {
    foreach p ". $args" {
	set x ""
	catch {
	    set x [glob -directory $p tf* td*]
	}
	foreach file $x {
	    if {
		[catch {file delete -force -- $file}]
		&& [testConstraint testchmod]
	    } then {
		openup $file
		file delete -force -- $file
	    }
	}
    }
}

test unixFCmd-1.1 {TclpRenameFile: EACCES} {unix notRoot} {
    cleanup
    file mkdir tdInixFCmd1/td2/td3
    file attributes tdInixFCmd1/td2 -permissions 0000
    set msg [list [catch {file rename tdInixFCmd1/td2/td3 td2} msg] $msg]
    file attributes tdInixFCmd1/td2 -permissions 0755
    set msg
} {1 {error renaming "tdInixFCmd1/td2/td3": permission denied}}
test unixFCmd-1.2 {TclpRenameFile: EEXIST} {unix notRoot} {
    cleanup
    file mkdir tdInixFCmd1/td2
    file mkdir td2
    list [catch {file rename td2 tdInixFCmd1} msg] $msg
} {1 {error renaming "td2" to "tdInixFCmd1/td2": file already exists}}
test unixFCmd-1.3 {TclpRenameFile: EINVAL} {unix notRoot} {
    cleanup
    file mkdir tdInixFCmd1
    list [catch {file rename tdInixFCmd1 tdInixFCmd1} msg] $msg
} {1 {error renaming "tdInixFCmd1" to "tdInixFCmd1/tdInixFCmd1": trying to rename a volume or move a directory into itself}}
test unixFCmd-1.4 {TclpRenameFile: EISDIR} {emptyTest unix notRoot} {
    # can't make it happen
} {}
test unixFCmd-1.5 {TclpRenameFile: ENOENT} {unix notRoot} {
    cleanup
    file mkdir tdInixFCmd1
    list [catch {file rename td2 tdInixFCmd1} msg] $msg
} {1 {error renaming "td2": no such file or directory}}
test unixFCmd-1.6 {TclpRenameFile: ENOTDIR} {emptyTest unix notRoot} {
    # can't make it happen
} {}
test unixFCmd-1.7 {TclpRenameFile: EXDEV} {unix notRoot} {
    cleanup
    file mkdir fooUnixFCmd/bar
    file attr fooUnixFCmd -perm 040555
    set catchResult [catch {file rename fooUnixFCmd/bar /tmp} msg]
    set msg [lindex [split $msg :] end]
    catch {file delete /tmp/bar}
    catch {file attr fooUnixFCmd -perm 040777}
    catch {file delete -force fooUnixFCmd}
    list $catchResult $msg
} {1 { permission denied}}
test unixFCmd-1.8 {Checking EINTR Bug} {unix notRoot nonPortable} {
    testalarm 
    after 2000
    list [testgotsig] [testgotsig]
} {1 0}
test unixFCmd-1.9 {Checking EINTR Bug} {unix notRoot nonPortable} {
    cleanup
    set f [open tfalarm w]
    puts $f {
	after 2000
	puts "hello world"
	exit 0
    }
    close $f
    testalarm 
    set pipe [open "|[info nameofexecutable] tfalarm" r+]
    set line [read $pipe 1]
    catch {close $pipe}
    list $line [testgotsig]
} {h 1}

test unixFCmd-2.1 {TclpCopyFile: target exists: lstat(dst) == 0} \
	{unix notRoot} {
    cleanup
    close [open tfunixFCmd1 a]
    close [open tfunixFCmd2 a]
    file copy -force tfunixFCmd1 tfunixFCmd2
} {}
test unixFCmd-2.2.1 {TclpCopyFile: src is symlink} {unix notRoot dontCopyLinks} {
    # copying links should end up with real files
    cleanup
    close [open tfunixFCmd1 a]
    file link -symbolic tfunixFCmd2 tfunixFCmd1
    file copy tfunixFCmd2 tf3
    file type tf3
} {file}
test unixFCmd-2.2.2 {TclpCopyFile: src is symlink} {unix notRoot} {
    # copying links should end up with the links copied
    cleanup
    close [open tfunixFCmd1 a]
    file link -symbolic tfunixFCmd2 tfunixFCmd1
    file copy tfunixFCmd2 tf3
    file type tf3
} {link}
test unixFCmd-2.3 {TclpCopyFile: src is block} {unix notRoot} {
    cleanup
    set null "/dev/null"
    while {[file type $null] != "characterSpecial"} {
	set null [file join [file dirname $null] [file readlink $null]]
    }
    # file copy $null tfunixFCmd1
} {}
test unixFCmd-2.4 {TclpCopyFile: src is fifo} {unix notRoot} {
    cleanup
    if [catch {exec mknod tfunixFCmd1 p}] {
	list 1
    } else {
	file copy tfunixFCmd1 tfunixFCmd2
	expr {"[file type tfunixFCmd1]" == "[file type tfunixFCmd2]"}
    }
} {1}
test unixFCmd-2.5 {TclpCopyFile: copy attributes} {unix notRoot} {
    cleanup
    close [open tfunixFCmd1 a]
    file attributes tfunixFCmd1 -permissions 0472
    file copy tfunixFCmd1 tfunixFCmd2
    file attributes tfunixFCmd2 -permissions
} 00472 ;# i.e. perms field of [exec ls -l tfunixFCmd2] is -r--rwx-w-

test unixFCmd-3.1 {CopyFile not done} {emptyTest unix notRoot} {
} {}

test unixFCmd-4.1 {TclpDeleteFile not done} {emptyTest unix notRoot} {
} {}

test unixFCmd-5.1 {TclpCreateDirectory not done} {emptyTest unix notRoot} {
} {}

test unixFCmd-6.1 {TclpCopyDirectory not done} {emptyTest unix notRoot} {
} {}

test unixFCmd-7.1 {TclpRemoveDirectory not done} {emptyTest unix notRoot} {
} {}

test unixFCmd-8.1 {TraverseUnixTree not done} {emptyTest unix notRoot} {
} {}

test unixFCmd-9.1 {TraversalCopy not done} {emptyTest unix notRoot} {
} {}

test unixFCmd-10.1 {TraversalDelete not done} {emptyTest unix notRoot} {
} {}

test unixFCmd-11.1 {CopyFileAttrs not done} {emptyTest unix notRoot} {
} {}

test unixFCmd-12.1 {GetGroupAttribute - file not found} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    list [catch {file attributes fooUnixFCmd.test -group} msg] $msg
} {1 {could not read "fooUnixFCmd.test": no such file or directory}}
test unixFCmd-12.2 {GetGroupAttribute - file found} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    close [open fooUnixFCmd.test w]
    list [catch {file attributes fooUnixFCmd.test -group}] [file delete -force -- fooUnixFCmd.test]
} {0 {}}

test unixFCmd-13.1 {GetOwnerAttribute - file not found} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    list [catch {file attributes fooUnixFCmd.test -group} msg] $msg
} {1 {could not read "fooUnixFCmd.test": no such file or directory}}
test unixFCmd-13.2 {GetOwnerAttribute} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    close [open fooUnixFCmd.test w]
    list [catch {file attributes fooUnixFCmd.test -owner} msg] \
	    [string compare $msg $user] [file delete -force -- fooUnixFCmd.test]
} {0 0 {}}

test unixFCmd-14.1 {GetPermissionsAttribute - file not found} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    list [catch {file attributes fooUnixFCmd.test -permissions} msg] $msg
} {1 {could not read "fooUnixFCmd.test": no such file or directory}}
test unixFCmd-14.2 {GetPermissionsAttribute} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    close [open fooUnixFCmd.test w]
    list [catch {file attribute fooUnixFCmd.test -permissions}] \
	    [file delete -force -- fooUnixFCmd.test]
} {0 {}}

#groups hard to test
test unixFCmd-15.1 {SetGroupAttribute - invalid group} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    list [catch {file attributes fooUnixFCmd.test -group foozzz} msg] \
	    $msg [file delete -force -- fooUnixFCmd.test]
} {1 {could not set group for file "fooUnixFCmd.test": group "foozzz" does not exist} {}}
test unixFCmd-15.2 {SetGroupAttribute - invalid file} \
	{unix notRoot foundGroup} {
    catch {file delete -force -- fooUnixFCmd.test}
    list [catch {file attributes fooUnixFCmd.test -group $group} msg] $msg
} {1 {could not set group for file "fooUnixFCmd.test": no such file or directory}}

#changing owners hard to do
test unixFCmd-16.1 {SetOwnerAttribute - current owner} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    close [open fooUnixFCmd.test w]
    list [catch {file attributes fooUnixFCmd.test -owner $user} msg] \
	    $msg [string compare [file attributes fooUnixFCmd.test -owner] $user] \
	    [file delete -force -- fooUnixFCmd.test]
} {0 {} 0 {}}
test unixFCmd-16.2 {SetOwnerAttribute - invalid file} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    list [catch {file attributes fooUnixFCmd.test -owner $user} msg] $msg
} {1 {could not set owner for file "fooUnixFCmd.test": no such file or directory}}
test unixFCmd-16.3 {SetOwnerAttribute - invalid owner} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    list [catch {file attributes fooUnixFCmd.test -owner foozzz} msg] $msg
} {1 {could not set owner for file "fooUnixFCmd.test": user "foozzz" does not exist}}


test unixFCmd-17.1 {SetPermissionsAttribute} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    close [open fooUnixFCmd.test w]
    list [catch {file attributes fooUnixFCmd.test -permissions 0000} msg] \
	    $msg [file attributes fooUnixFCmd.test -permissions] \
	    [file delete -force -- fooUnixFCmd.test]
} {0 {} 00000 {}}
test unixFCmd-17.2 {SetPermissionsAttribute} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    list [catch {file attributes fooUnixFCmd.test -permissions 0000} msg] $msg
} {1 {could not set permissions for file "fooUnixFCmd.test": no such file or directory}}
test unixFCmd-17.3 {SetPermissionsAttribute} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    close [open fooUnixFCmd.test w]
    list [catch {file attributes fooUnixFCmd.test -permissions fooUnixFCmd} msg] $msg \
	    [file delete -force -- fooUnixFCmd.test]
} {1 {unknown permission string format "fooUnixFCmd"} {}}
test unixFCmd-17.4 {SetPermissionsAttribute} {unix notRoot} {
    catch {file delete -force -- fooUnixFCmd.test}
    close [open fooUnixFCmd.test w]
    list [catch {file attributes fooUnixFCmd.test -permissions ---rwx} msg] $msg \
	    [file delete -force -- fooUnixFCmd.test]
} {1 {unknown permission string format "---rwx"} {}}

close [open fooUnixFCmd.test w]
set ::i 4
proc permcheck {testnum permList expected} {
    test $testnum {SetPermissionsAttribute} {unix notRoot} {
      set result {}
      foreach permstr $permList {
	file attributes fooUnixFCmd.test -permissions $permstr
	lappend result [file attributes fooUnixFCmd.test -permissions]
      }
      set result
    } $expected
}
permcheck unixFCmd-17.5   rwxrwxrwx	00777
permcheck unixFCmd-17.6   r--r---w-	00442
permcheck unixFCmd-17.7   {0 u+rwx,g+r u-w o+rwx} {00000 00740 00540 00547}
permcheck unixFCmd-17.11  --x--x--x	00111
permcheck unixFCmd-17.12  {0 a+rwx} {00000 00777}
file delete -force -- fooUnixFCmd.test

test unixFCmd-18.1 {Unix pwd} {nonPortable unix notRoot} {
    # This test is nonportable because SunOS generates a weird error
    # message when the current directory isn't readable.
    set cd [pwd]
    set nd $cd/tstdir
    file mkdir $nd
    cd $nd
    file attributes $nd -permissions 0000
    set r [list [catch {pwd} res] [string range $res 0 36]];
    cd $cd;
    file attributes $nd -permissions 0755
    file delete $nd
    set r
} {1 {error getting working directory name:}}

test unixFCmd-19.1 {GetReadOnlyAttribute - file not found} {unix notRoot readonlyAttr} {
    catch {file delete -force -- fooUnixFCmd.test}
    list [catch {file attributes fooUnixFCmd.test -readonly} msg] $msg
} {1 {could not read "fooUnixFCmd.test": no such file or directory}}
test unixFCmd-19.2 {GetReadOnlyAttribute} {unix notRoot readonlyAttr} {
    catch {file delete -force -- fooUnixFCmd.test}
    close [open fooUnixFCmd.test w]
    list [catch {file attribute fooUnixFCmd.test -readonly} msg] $msg \
	    [file delete -force -- fooUnixFCmd.test]
} {0 0 {}}

test unixFCmd-20.1 {SetReadOnlyAttribute} {unix notRoot readonlyAttr} {
    catch {file delete -force -- fooUnixFCmd.test}
    close [open fooUnixFCmd.test w]
    list [catch {file attributes fooUnixFCmd.test -readonly 1} msg] $msg \
	    [catch {file attribute fooUnixFCmd.test -readonly} msg] $msg \
	    [catch {file delete -force -- fooUnixFCmd.test}] \
	    [catch {file attributes fooUnixFCmd.test -readonly 0} msg] $msg \
	    [catch {file attribute fooUnixFCmd.test -readonly} msg] $msg \
	    [file delete -force -- fooUnixFCmd.test]
} {0 {} 0 1 1 0 {} 0 0 {}}
test unixFCmd-20.2 {SetReadOnlyAttribute} {unix notRoot readonlyAttr} {
    catch {file delete -force -- fooUnixFCmd.test}
    list [catch {file attributes fooUnixFCmd.test -readonly 1} msg] $msg
} {1 {could not read "fooUnixFCmd.test": no such file or directory}}

# cleanup
cleanup
cd $oldcwd
::tcltest::cleanupTests
return

# Local Variables:
# mode: tcl
# End:
